Function Enter-VSSExposeBackupSession {
    <#
    .SYNOPSIS
    Expose a VSS Snapshot of an Exchange Database on Pure Flash Array to mount point(s).
    
    .DESCRIPTION
    Expose a VSS snapshot to a mount point(s) in c:\program files\pure storage\vss\exchange\<DB name>\mp1|mp2.
    After exposing, pause script. Manual manipulation of files, such as robocopy, then type 'exit' and press ENTER to continue the script.
    The script will then unexpose the volume(s) and end.

    This function will fail on a VM, unless the in-guest Microsoft iSCSI initiator is used to connect to the FlashArray and the force flag.

    .EXAMPLE
    Load the Script then run the New-ExchRestore function:
    . ./PureExchangeWrapper.psm1
        
    Expose Database DB1
    Enter-VSSExposeBackupSession -DBName DB1

    Expose Database DB2 on a VM with in-guest iSCSI
    Enter-VSSExposeBackupSession -DBName DB2 -Force
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [Parameter(Position = 0)]
        [string]$DBName,
        [Parameter(Mandatory = $false)]
        [Parameter(Position = 1)]
        [switch]$Force,
        [Parameter(ParameterSetName='ScriptBlock')]
        [scriptblock]$ScriptBlock
    )
   
    process {
        $script:pc = Get-CimInstance -Class Win32_ComputerSystem
        $isVm = $pc.Model.StartsWith('VMware') -or $pc.Model.StartsWith('Virtual')

        if ($isVm -and -not $Force) { 
            Write-Error @'
VM detected. Expose will only work if the database is on an iSCSI Volume directly mapped through the guest initiator.
If this is the case, use:  -Force
Example: New-ExposeBackup -DBName DB1 -Force
'@
        }

        $rootPath = 'c:\program files\pure storage\vss\exchange\'
        $dbPath = Join-path $rootPath $DBName
        New-Variable -Name mp1 -Value (Join-Path $dbPath 'mp1') -Option ReadOnly
        New-Variable -Name mp2 -Value (Join-Path $dbPath 'mp2') -Option ReadOnly
        Write-Host "Exposing snapshot to mount points under $mp1"
        Write-Host "If logs are on a separate volume, they are exposed on $mp2"
        Write-Host 'This will fail if files or subdirectories have been created under the mp1/mp2 folders'
        
        $cabFile = Get-ChildItem $dbPath -File | Out-GridView -Title 'Choose a CAB file' -OutputMode Single
        if (-not $cabFile) {
            Write-Error "No cab file selected. Terminating."
        }

        $cabName = $cabFile.FullName #full path and file Name
    
        #   Get the mailbox database
        $mailboxDb = Get-MailboxDatabase -id $DBName
    
        #   Grab disk path to pass to diskshadow
        New-Variable disk1 (Get-Volume -FilePath $mailboxDb.edbfilepath).Path -Option ReadOnly
        New-Variable disk2 (Get-Volume -FilePath $mailboxDb.logfolderpath).Path -Option ReadOnly
        New-Variable cabExcludeSuffix [io.path]::GetFileNameWithoutExtension($cabName) -Oprion ReadOnly
            
        New-Item -ItemType Directory -Path $mp1 -ErrorAction SilentlyContinue
        New-Item -ItemType Directory -Path $mp2 -ErrorAction SilentlyContinue

        $script = './tmp.dsh'
        "Load metadata ""$cabName""",
        'IMPORT',
        "expose %$($cabExcludeSuffix)_01% ""$mp1""" | Set-Content $script
        if ($disk1 -ne $disk2) { "expose %$($cabExcludeSuffix)_02% ""$mp2""" | Add-Content $script } 
        diskshadow /s $script
        Remove-Item $script

        $cwd = Get-Location
        
        if ('ScriptBlock' -eq $PSCmdlet.ParameterSetName) {
            $argList = @(
                $DBName, $mp1
                if ($disk1 -ne $disk2) { $mp2 }
            )

            Invoke-Command -ScriptBlock $ScriptBlock -ArgumentList $argList

        } else {
            function prompt {  "Enter 'exit' command to continue after copying files from the exposed backup Volume(s) to cleanup and unexpose the Volume(s).`n$(Get-Location) > " }
            $HOST.EnterNestedPrompt();
        }

        Set-Location $cwd

        $script = './tmp.dsh'
        "unexpose %$($cabExcludeSuffix)_01% ""$mp1""" | Set-Content $script
        if ($disk1 -ne $disk2) { "unexpose %$($cabExcludeSuffix)_02% ""$mp2""" | Add-Content $script } 
        diskshadow /s $script
        Remove-Item $script

        Write-Host 'Exposed disk(s) have been removed. Cleanup Complete.'
    }
}#END New-VSSExposeBackup{}
